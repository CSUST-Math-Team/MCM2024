%--------------------------------------------------------------------------
%               基于K均值聚类的图像分割――灰度图像
%--------------------------------------------------------------------------

%*******************************读取图像数据********************************
x = imread('coins.png');    %读入一幅图像，得到图像数据x
whos x    % 查看矩阵x的大小和类型
y = double(x(:));    %将图像数据x按列拉长成一个长向量


%*************************调用kmeans函数进行聚类分割*************************
startdata = [0; 150];    % 设定初始凝聚点
idpixel = kmeans(y,2,'Start',startdata);    % 进行K均值聚类，所有像素点聚为2类
% 根据聚类结果生成一个与idpixel等长的逻辑向量idbw
idbw = (idpixel == 2);
% 将idbw还原成一个与x同样大小的逻辑矩阵，背景像素点对应元素值为0，前景像素点对应元素值为1
result = reshape(idbw, size(x));
imshow(result);    %以二值图像方式显示图像分割结果



%--------------------------------------------------------------------------
%               基于K均值聚类的图像分割――真彩图像
%--------------------------------------------------------------------------

%*******************************读取图像数据********************************
% 读入一幅图像，得到图像数据Duck0
Duck0 = imread('littleduck.jpg');
% 查看数组Duck0的大小和类型
whos  Duck0
% 求数组Duck0的行数m，列数n，页数k
[m,n,k] = size(Duck0);
% 将数组Duck0转成m*n行，3列的双精度矩阵
Duck1 = double(reshape(Duck0, m*n, k));
% 查看数组Duck1的大小和类型
whos  Duck1


%*************************调用kmeans函数进行聚类分割*************************
% 设定背景和前景初始凝聚点
startdata = [10 10 200;200 200 10];
% 进行K均值聚类，所有像素点聚为2类：背景和前景，
% idClass = 1对应的是背景，idClass = 2对应的是前景
idClass = kmeans(Duck1,2,'Start',startdata);
% 生成背景索引矩阵idDuck
idDuck = (idClass == 1);
% 生成背景索引数组result
result = reshape([idDuck, idDuck, idDuck],[m,n,k]);
% 为了不覆盖原始原始图像数据Duck0，定义一个新的数组Duck2
Duck2 = Duck0;
% 根据背景索引数组result，把Duck2中背景像素点的红、绿、蓝三元色灰度值均设置为0
Duck2(result) = 0;
% 创建一个空白图形窗口
figure
% 显示前景图像，此时的背景为黑色
imshow(Duck2)
